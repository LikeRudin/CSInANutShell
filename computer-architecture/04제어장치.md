# 04 제어장치

# CONTENTS

    - 1. 제어장치의 구성

                - 명령어 레지스터
                - 명령어 해독기
                - 주소처리기
                - 순서제어기
    
    - 2. 제어장치의 구현

            - A. 마이크로 프로그램 이용
                    
                    - 제어장치 구성 
                    
                            - 제어기억장치
                            - 제어주소 레지스터
                            - 제어데이터 레지스터
                            - 다음 주소 생성기
                    
                    - 마이크로 명령어
                    
                        - 형식
                
            -  B. 하드웨어 이용
                    
                    - 상태 플립플롭 방식
                    - 순차레지스터  + 디코더 방식

---

# DETAILS

## 1. 제어장치의 구성

### 제어장치와 처리장치의 상호작용

처리장치가 `컴퓨터 명령어`를 입력받아 이에 해당하는  `마이크로 연산(제어신호)`을 처리장치로 전송

처리장치는 결과를 출력하고, `상태신호`를 제어장치에 전송
- 상태신호는 분기와 같은 판단기준을 제공

### 명령어 레지스터 (IR: Instruction Register)

기억장치에서 가져온 명렁어를 잠시 저장

- 명령어 = 연산코드 + 오퍼랜드
- 연산코드는 명렁어해독기로, 오퍼랜드는 주소처리기로 전송

### 명령어 해독기

명령어의 연산코드를 해독함

### 주소처리기

명령어의 오퍼랜드를 해석하여 다음 명령어의 주소나 오퍼랜드 획득

### 순서제어기 (Sequencer)

제어기억장치에서 제어단어를 읽어올 순서를 결정

## 2. 제어장치의 구현

### A. 마이크로 프로그램 이용

![](https://www.geeksforgeeks.org/wp-content/uploads/2-9.jpg)

- 마이크로 명령어 (microinstruction)
    - 하나이상의 마이크로연산

<br>

- 마이크로프로그램(microprogram)
    - 순차적인 마이크로명령어들의 집합


```
제어기억장치: ROM / RAM 
- 모든 제어정보 저장

제어주소 레지스터 (CAR Control Address Register)
- 제어기억장치에있는 마이크로 명령어의 주소 보관

제어데이터 레지스터 (CDR: Control Data Register)
- 제어기억장치에서 읽어온 마이크로명렁어 저장

다음 주소 생성기
- 제어기억장치에서 제어단어를 읽어내는 순서 결정
```

## B. 하드웨어 이용


![](https://www.geeksforgeeks.org/wp-content/uploads/1-9.jpg)

- 명령어 레지스터
    - 기억장치로부터 읽어들여온 명령어 보관

<BR>

- 디코더
    - 입력된 명령어를 해독
    - 값을 필터링하는역할

<br>

- 타이밍 발생기 ()
    - 클록을 입력으로 받아 타이밍 신호를 발생시켜 작업을 동기화

<br>


- 제어장치
    - 제어신호 출력


### 상태플립플롭 방식

순서제어회로의 각 상태마다 플립플롭 1개를 할당


### 순서레지스터 + 디코더 방식

- 순서레지스터
    - 제어상태의 순서를 정함

<br>

- 디코더
    - 신호가 하나만 출력되도록 필터링


---

# QUESTION

제어장치가 어떻게 제어신호를 발생시키는지 설명하시오

# ANSWER

![](https://blog.kakaocdn.net/dn/M7gOL/btqzEizIrbp/Nm4Ni6iBuBFkSGw106MXRK/img.png)

1. `PC`에 저장된 다음실행 명령어의 주소를  메모리 주소 레지스터: `MAR`로 전송

2. `MAR`이 가지고있는 주소값을토대로 명령어를 기억장치에서 꺼내 메모리 버퍼 레지스터 `MBR`을거쳐 명령어 레지스터 `IR`에 저장

    이때, `PC`의 값을 1 증가시킨다.
오퍼랜드도 같은 방식을 통해 인출


3. IR에서 연산코드는 `명령어 해독기`로, 실제 연산값이 아닌 오퍼랜드는 `주소처리기`로 전송.

4. `주소처리기`는 오퍼랜드필드의 값을 넘겨받아 명령 수행에 필요한 `실제 오퍼랜드의 유효주소` 혹은 `다음 명령어의 주소`를 계산.

5. 제어 신호 발생기는 1~4 과정을 통해 필요해 `명령어`를 해독하여 `처리장치`가 수행할 연산을 알려주는 `제어신호`를 발생. 

6. 현재 `IR`에 있는 명령어의 수행이 끝나면, 처리장치로부터 `상태신호` 를 건네받고, `PC`는 다음에 수행할 명령어의 주소를 지정


문제 해설참고 : https://atoz-develop.tistory.com/entry/%EC%A0%9C%EC%96%B4%EC%9E%A5%EC%B9%98-%EC%A0%9C%EC%96%B4%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B5%AC%EC%84%B1%EA%B3%BC-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%88%98%ED%96%89-%EA%B3%BC%EC%A0%95