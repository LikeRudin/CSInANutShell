# 05 중앙처리장치

# CONTENTS

    - 1. 레지스터

                - 범용 레지스터
                    
                - 특수 레지스터
                    - 프로그램 카운터
                    - 기억장치 주소 레지스터
                    - 스택포인터
                    - 명령어 레지스터
                    - 기억장치 버퍼 레지스터
                    - 누산기

    - 2. 명령어 사이클
                    
                - 인출
                - 실행
                - 간접
                - 인터럽트

    - 3. 명령어 파이프라이닝 

                - 2단계                    
                - 4단계
                - 6단계

    - 4. CISC vs RISC 

                - 명렁어 집합
                - 제어장치 구성
                - 레지스터 구성
                - 파이프라인 적용 효율

---

# DETAILS

## 1. 레지스터

- 레지스터: 고속 기억장치

    - CPU내부에 존재하는 소규모의 기억장치
    - 금방 사용할 데이터를 잠깐 보관하는데 사용

<BR>

### 범용 레지스터

데이터 저장, 주소 저장과 같은 일반적인 목적을 위해 사용되는 레지스터

<BR>

### 특수 레지스터

### 1. 프로그램 카운터(PC: Program Counter)

    - 데이터가 저장되어있는 주소 지정

    - 데이터를 인출후 값이 자동으로 1증가 -> 다음 명령어 주소 지정
    
    - CPU가 지정할 수있는 기억장치의 전체 영역을 지정
    
        - 기억장치가 256MB => 2^28 => PC는 28비트
<BR>

### 2. 기억장치 주소 레지스터(MAR: Memory Address Register)

    - 기억장치 주소를 일시 저장

<BR>

### 3. 스택 포인터 (SP: Stack Pointer)

    - 프로그램 카운터와 같은 크기의 비트수를 가짐

    - 스택주소지정방식에서 사용

        - 실제로 데이터가 저장되는 기억장소로 기억장치에 위치

<BR>

### 4. 명령어 레지스터 (IR: Instruction Register) <br>

    - 기억장치로부터 가장 최근에 인출된 명령어 보관

    - 비트수는 명령어 연산코드의 비트수와 동일

<BR>

### 5. 기억장치 버퍼 레지스터(MBR: Memory Buffer Register)

    - 기억장치에 저장되거나, 기억장치로부터 불러올 데이터를 임시 저장

<BR>

### 6. 누산기(AC: Accumulator)

    - 데이터를 일시 저장하는 레지스터

    - 데이터를 입력장치로부터 받거나, 출력장치로 전송하는데에 사용

    - 산술/논리 연산시 오퍼랜드나 연산결과를 일시적으로 기억

    - CPU가 연산을 수행한 후 그 결과는 반드시 누산기에 저장

<BR>

## 2. 명령어 사이클 (instruction cycle)

1개의 명령어를 CPU에서 수행하는데 필요한 전체 수행과정

<BR>

### 1. 인출 사이클 (fetch)

기억장치에 저장된 데이터를 인출

- 마이크로 연산표현 

```
T0 : MAR <- PC                     다음 명령어의 주소를 PC에서 MAR로 이동
T1 : MBR <- M[MAR], PC <- (PC) +1  MAR 주소에 저장된 값을 MBR로 이동 , PC 값 1 증가 
T2 : IR  <- MBR                    MBR의 명령어를 실행시키기 위해 IR로 이동 

T- 클록: 실행주기 단위
```

### 2. 실행 사이클 (execute cycle)

명령어를 실행

- 마이크로 연산표현

```
LOAD: 기억장치 데이터를 CPU 내부 레지스터인 누산기로 전송

T0 : MAR <- IR(adrs)               데이터가 들어있는 주소가 MAR로 이동
T1 : MBR <- M[MAR]                 MAR에 들어있는 주소의 데이터 를 MBR로 이동
T2 : AC  <- MBR                    MBR에 저장된 값을 누산기로 이동
```

```
ADD: 누산기의 데이터와 기억장치의 데이터를 더한 후 누산기에 저장

T0 : MAR <- IR(adrs)               더해줄 데이터가 들어있는 주소가 MAR로 이동
T1 : MBR <- M[MAR]                 MAR에 들어있는 주소의 데이터 를 MBR로 이동
T2 : AC  <- AC + MBR               MBR에 저장된 값 + 누산기 값의 연산결과를 누산기로 이동
```

```
STORE: 누산기의 데이터를 기억장치에 저장

T0 : MAR <- IR(adrs)               값이 저장될 주소가 MAR에 실린다.
T1 : MBR <- AC                     누산기의 데이터가 MBR에 실린다.
T2 : M[MAR]  <- MBR                MBR의 데이터가 MAR에 있는 주소에 저장된다
```

```
Branch / Jump  분기나 점프: 제어기능을 수행, 
                            다음 실행 명령어는 PC 값이아니라 분기 /점프 명령어가
                            전달해준 값을 실행

T0 : PC <- IR(adrs)                 분기 혹은 점프 명령어에 있는 주소가 PC에 실린다.
```

```
CALL: 서브루틴 또는 프로시저라고 부르는 프로그램 일부분으로 분기룰 수행.

T0 : MAR <- IR(adrs)               분기할 명령어의 주소가 MAR로 전송
T1 : M[MAR] <- PC, PC <- MAR + 1   PC의 주소가 MAR이 지정한 주소로 저장, PC에는 MAR이 지정한 주소 +1이 적재
T2 : PC  <- MAR                    서브루틴 실행후 MAR에 저장된 주소가 다시 PC로 복귀
```

<BR>

### 3. 간접 사이클 (indirect cycle)

간접 주소지정방식을 사용하는 명령어에서 `오퍼랜드 부분의 유효주소`를 결정

```
T0 : MAR <- IR(adrs)               명령어의 주소가 MAR로 전송
T1 : MBR <- M[MAR]                 MAR이 지정한 주소의 데이터가 MBR로 전송
T2 : iR  <- MBR                    MBR에 있는 데이터가 IR의 주소필드에 적재
```

<BR>

### 4. 인터럽트 사이클 (interrupt cycle)


인터럽트 처리요청이 오면 인터럽트를 실행하는 과정

- 인터럽트: PC가 현재 처리중인 프로그램 루틴을 중단, 다른동작을 수행

    - 하드웨어: 입출력 장치에의해 발생

    - 소프트웨어: 프로세스 오류등에 의해발생


```
T0 : MBR <- PC                     인터럽트 처리후 복귀할 명령어의 주소 (PC의 주소)를 MBR에 적제
T1 : MAR <- SP,  PC <- ISR(adrs)   입출력장치의 명령어를 PC에 적재, 스택포인터의 값을 MAR에 저장
T2 : M[MAR]  <- MBR                복귀할 명령어를 MAR주소에 담긴값(스택 포인터)에 지정           
```

<BR>

## 3. 명령어 파이프라이닝

병렬처리 기법중 하나


- 파이프라이닝(pipelining)

    - 어떤 일을 여러단계로 나누고, 중첩되게 실행함으로써 성능을 높이는 방법

<BR>

- 명령어 파이프라이닝(instruction pipelining)
 
    - 하나의 처리기를 여러개의 부 처리기로 나눔
 
    - 각 처리기가 서로 다른 데이터를 동시에 처리

<BR>

### 2단계 명렁어 파이프라인

명령어 인출, 실행 2단계로 나누어 처리

```
클록주기|  1   |  2   |  3  |  4   | ...  

명령어1 | 인출 | 실행 |
명령어2        | 인출 | 실행 |
명령어3               | 인출 | 실행 |

```

<BR>

### 4단계 명령어 파이프라인

명령어 인출, 해독, 오퍼랜드 인출, 명령어 실행  4단계로 나누어 처리

<BR>

### 6단계 명령어 파이프라인

명령어 인출, 해독, 오퍼랜드계산, 인출, 명령어 실행, 결과값(오퍼랜드) 저장  6단계로 나누어 처리

오퍼랜드 계산단계 

```
명령어의 피연산자가 실제 오퍼랜드인지 
오퍼랜드가 담긴 주소인지 판별하여 오퍼랜드를 구하는 단계
```
<BR>

### 파이프라인에 의한 속도향상 계산


```
- 파이프라인 X

T = K * N


- 파이프라인 사용시 

T = `K` + (N - 1)

T: 전체 소요시간
K: 작업의 단계 수
N: 명령어 개수


속도 향상률

SP = (K * N) / {k + (N -1)}
```

단, 위의 공식은 전체 명령어의 단계 수와 수행시간이 동일하다고 가정했을때
나오는 이상적인 비율이다.


- 파이프라인 속도향상 제한요소

    - 구조적 요소: 2개이상의 명령어가 같은단계에서 같은 하드웨어 접근 X

    - 제어적 요소: 명령어는 정해진순서대로, 최대한 인터럽트나 분기가없이 수행되어야함


<BR>

## 4. 복합명령어 집합 컴퓨터와 단축 명령어 집합 컴퓨터의 비교

명령어 집합의 복잡성에 따라 다음과 같이 구분한다


- 복합 명령어 집합 컴퓨터(CISC: Complex Instruction Set Computer)

    - 전체 명령어의 수를 줄일 수 있어, 프로그램실행시간 단축

<BR>

- 단축 명령어 집합 컴퓨터(CISC: Complex Instruction Set Computer)

    - 각 명령어의 길이를 가능한 줄여, 명령어 실행시간을 최소화


|구분|CISC|RISC|
|--|--|--|
|명령어 길이|가변|고정|
|명령어 수행사이클|다양함|1클록고정|
|파이프라인효율|나쁨|좋음|
|명령어 개수|200개이상|30개정도|
|제어장치 구성|마이크로 프로그램|하드웨어|
|범용레지스터|적음| 많음|

---

# QUESTION

인터럽트및 인터럽트 사이클에대해 설명하고, 예시 어셈블리어 코드를 제시하시오