# CONTENTS

```
    - 1. 가상 메모리 개요
    - 2. 블록단위 주소변환
        - 페이징
        - 세그멘테이션
        - 페이징 / 세그멘테이션 혼용

    - 3. 페이지 호출기법
        - 요구 페이지 호출
        - 예상페이지 호출

    - 4. 페이지 교체기법
        - FIFO
        - LRU
        - LFU
        - NUR
        - 2차 기회페이지
        - 클럭페이지
        - 프로세스별 페이지 집합관리
```

---

# DETAILS

# 1. 가상 메모리 개요

### virtual memory

컴퓨터 시스템의 메모리 크기보다 더 큰 기억공간이 필요한 프로세스를 실행하기 위한 방법

전체 프로그램 데이터중 일부만 메모리에 적재하여 구현

실행중인 프로세스가 참조할 주소를 메모리에서 사용하는 주소와 분리하는것

### 용어

1.  가상주소 (virtual address): 실행프로세스가 참조하는 주소.

2.  실주소 또는 물리주소 (real or psysical address) 실제 메모리에서 사용하는 주소.

3.  사상(mapping): 명령어를 메모리에서 실행하기위해 가상주소에서 실주소로 변환하는 함수

4.  인위적 연속성 (contiguity): 실 주소공간에서는 연속적으로 배치되지 않았지만, 가상주소의 연속적 배치 를 나타냄

5.  동적 주소변환 (Dynamic Address Translation, `DAT`) : 프로세스가 실행되는 동안 가상주소를 실주소로 변환하는 절차

# 2. 블록단위 주소변환 기법

동적 주소변환을 수행하기 위해서 가상 메모리 위차와 현재 메모리 위치가
대응되는 주소변환 사상표 (address translation mapping table)이 필요

![](https://denninginstitute.com/itcore/virtualmemory/images/Translation.gif)

- 전체 프로그램 데이터는 너무 크므로, 해당 데이터를 블록단위로 분류하여, 각 블록에대한 주소만을 관리
  - 주기억장치 위치

가상주소(v) 는 참조될 항목이있는 블록번호 b와, 해당 블록의 시작점으로부터 항목까지의 변위(displacement)를 이용하여 표기

| 블록번호 | 변위 |
| -------- | ---- |
| b        | d    |

- 한 층에 한 가구만 있는 대단지 아파트면 b는 동의 이름, d는 층수라고 할 수있음

## 2.1 페이징 paging

가상메모리를 고정된 크기의 블록(page)로 나누는 기법

책의 페이지와 같은 단어, 고정 규격을 가졌음을 의미

- 메모리영역도 가상메모리와 동일하게 고정된 크기의 블록(page frame)으로 나눔

### 동적 주소변환 수행 기법

1. 직접사상

   - 페이지 사상표를 직접 이용

| 페이지 번호 | 페이지 존재 비트 | 보조기억장치 주소 | 페이지 프레임 번호 |
| ----------- | ---------------- | ----------------- | ------------------ |
| 3           | 1 or 0           | s                 | 5                  |

![](https://cstaleem.com/wp-content/uploads/2020/05/Paging-in-operating-system.jpg)

역 페이지 사상
![](https://cstaleem.com/wp-content/uploads/2020/05/Inverted-Page-table-IPT-in-OS.jpg)

2. 연관사상

- 페이지 변환 정보를 연관 기억장치에 저장한 연관 사상표를 이용

3. 직접/연관 사상
   - 연관 사상표와 페이지 사상표를 전부 사용하는 방법
   - 최근에 참조된 페이지는 연관사상표에, 나머지 전부는 페이지 사상표에 기록
   - 참조 대상이 연관 사상표에 존재한다면 고속으로 참조 가능,
     그렇지 않다면 페이지 사상표를 통해 참조
     - 캐시의 히트와 미스와 비슷한 방법: 캐시에 존재하면 히트! 그렇지않으면 미스 보조기억장치로 이동

## 2.2 세그멘테이션 segmentation

가상메모리를 필요한 만큼의 크기의 세그멘트(segment)로 나누는 기법

![](https://cstaleem.com/wp-content/uploads/2020/05/segmentation-in-operating-system.jpg)

## 2.3 페이징 / 세그멘테이션 혼용

세그멘트를 구성하는 단위 메모리 크기의 페이지를 두어서 2중 분할을 하는기법
페이징기법의 "쉬운 메모리 관리"와 세그멘트 기법의 "유동적 할당"에 대한 장점을 모두 취함

# 3. 페이지 호출기법

주기억장치로 옮길 페이지를 결정하는 기법

## 3.1 요구 페이지 호출 (demand page fetch strategy)

프로세스가 페이지를 요구하면, 해당 페이지를 메모리로 적재

## 3.2 예상페이지 호출 (prepaging)

곧 사용될것으로 예상되는 페이지를 메모리에 미리 옮겨 적재

# 4. 페이지 교체기법

페이징 기법에서는 모든 페이지 프레임이 사용되는것이 일반적

- 새로운 페이지를 적재하기위해선 적절한 교체대상 페이지를 선택해야함
- 선택한 페이지를 보조기억장치에 보관한 후 새로운 페이지를 적재

최적화 원칙에 따라, 앞으로 가장 오래동안 사용되지 않을 페이지를 교채 대상으로 선택해야함

- 교체작업을 수행하면 안되는 페이지도 존재
  - 슈퍼바이저 코드, 보조기억장치 드라이버, 타이밍 규칙이 있는 코드들, 데이터 버퍼영역등에 관한 페이지는 교체하지 않음ㄴ

## 4.1 FIFO

가장 먼저 적재된 페이지를 희생자로 선택하는것.

- 각 페이지가 메모리에 적재될떄의 시간을 기억
- 페이지 교체가 필요할 시 가장 먼저 저장된 페이지를 제거

단점

- 가장 먼저 적재되었다고, 더이상 사용할 일이 없는것은 아님
- 오히려 가장 오래 남아있는 페이지는 가장 많은 참조가 이루어질 가능성이 높음
- Belady의 이상현상: 프로세스에 더많은 수의 페이지를 할당할수록, 페이지 부재가 더많이 발생하는것
  - 자주 참조하지 않는 페이지의 메모리 상주기간이 길어져서 발생

## 4.2 LRU Least Recently Used

가장 오래사용하지않은 페이지를 선택하여 교체

국부성(locality) 휴리스틱에 의존

- 컴퓨터구조의 기억장치 파트에서 나온 시간적/공간적 지역성

- 구현방식
  - 1. 참조시간을 이용
    - 페이지 참조가 이루어질떄마다 테이블에 참조시간을 기록
    - 교체가 필요시, 가장 오래전에 참조된 페이지를 제거
  - 2. 페이지의 참조정보를 보관하는 리스트를 이용
    - 참조가 이루어질때마다 해당 페이지에대한 정보를 리스트의 맨 앞으로 이동
    - 교체가 필요한 시점에서 리스트 끝에 등록되어있는 페이지를 제거

단점: 오버헤드

- 참조시간을 탐색하거나 리스트를 구성 및 관리하는것 전부 막대한 오버헤드를 발생
- 교체방법에대한 아이디어는 상당히 합리적이고 효율적인 방식이지만, 거의 사용되지 않음

## 4.3 LFU Least Frequently Used

각 페이지가 얼마나 많이 참조되었는지에대한 정보를 기록하여,
교체가 필요한 시점에서, 참조횟수가 가장 적은 페이지를 제거

단점: 오버헤드와 뷸균형한 페이지 선택

- 지금 막 메모리에 올라온 페이지가 교체될 확률이 큼
- 초기에 많이 참조되었으나, 현재는 거의 사용하지 않는 페이지는 교체되지 않음

## 4.4 NUR Not Used Recently

참조여부 및 수정여부에따라 4개의 그룹으로 페이지들을 분류하여
각 그룹별 우선순위에따라 교체 페이지를 결정

- LRU/LFU와 유사하면서 적은 오버헤드를 갖기 때문에 자주 이용됨

## 4.5 2차 기회페이지

페이지 정보 보관 큐에 참조 정보 비트를 삽입하여 FIFO를 보완한 방법

- 참조비트 작동 절차

  - 페이지를 메모리에 할당시 0으로 설정
  - 참조시 1로 설정

- 교체 페이지 선정 절차
  - 1. FIFO 큐의 가장 앞의 데이터를 확인
  - 2. 참조비트가 0이면 교체/1이면 0으로 변경후 큐의 가장 맨뒤로 위치이동
  - 3. 전부다 1일경우 일반 FIFO와 같은 방식으로 동작

## 4.6 클럭 페이지

2차 기회 페이지의 일종으로, 원형큐를 사용하는 방식

- 교체 페이지 선정 절차

페이지 정보와 참조비트가 들어있는 큐를 순회하며  
참조비트가 1인경우 0으로 변경, 0인경우 교체

- 정보를 직접 옮기지 않고, 포인터 하나가 큐를 순회하며 검사하므로 자원이 절약됨

![](https://media.geeksforgeeks.org/wp-content/uploads/20210208122704/cq2.jpeg)

## 4.7 프로세스별 페이지 집합관리

### Working set 알고리즘

워킹세트: 하나의 프로세스가 자주 참조하는 페이지의 집합

```
W(t.w) := t - w 로부터 t 까지의 프로세스시간 간격동안 참조된 페이지의 집합
```

워킹세트 알고리즘

프로세스의 워킹세트를 전부 메모리에 적재 할수 있을때만, 프로세스를 적재하는 방법

프로세스가 실행되면서 구성 페이지가 삭제되거나 추가되며,
전혀 다른 페이지로 구성된 워킹세트로 전이되기도한다

### PFF Page Fault Frequency 알고리즘

프로세스가 페이지 부재로인해 멈추는 빈도정보를 이용하여 상주 페이지 세트 구성 및 변경하는 알고리즘

두번의 페이지 부재 발생하는 시간간격을 통해 따라 빈도정보를 계산

페이지 부재율이 상한보다 높으면, 새로운 페이지를 상주 페이지 세트에 추가
하한보다 낮으면, 그 동안 참조되지 않은 페이지를 전부 제거

---

# QUESTION

1. 페이지 교체 알고리즘중 FIFO 알고리즘에 대해 설명하세요.
   페이지 교체 알고리즘의 주 목적에 입각한 단점과,
   FIFO를 개선한 다양한 다른 알고리즘도 함께 설명해주세요.

2. 가상 기억장치의 목적과 원리에 대하여 간단히 설명해주세요.

---

# ANSWER

1. 페이지 교체 알고리즘은, 메모리에 다음 페이지 적재를 위해
   현재 적재된 페이지중 메모리에서 제거할 항목을 결정하는 알고리즘입니다.

참조 가능성이 가장 적은 페이지를 선택하여야 합니다.
FIFO 알고리즘은 각 페이지가 적재된 시간을 기억하여, 가장 오래된 페이지를 우선적으로 제거하는 알고리즘입니다.

하지만 먼저 적재되었다고, 참조가능성도 가장 적은것은 아닙니다.
제일먼저 적재된 페이지가 빈번하게 참조되는 경우에는
제거하고 곧바로 다시적재할 가능성이있습니다.

그래서 참조에관한 비트를 추가한 2차기회 페이지 알고리즘이 있습니다.

메모리에 적재된 순서대로 페이지의 정보를 보관하는 큐를 둡니다.
제거할 메모리를 선정할때, 큐의 제일 앞에있는 페이지정보를 확인합니다.
만약 참조비트가 0이면 해당 페이지를 제거하고, 1이면 0으로 변경한 후 큐의 맨뒤로 옮깁니다.

또 이의 자료구조를 개선한 클럭 페이지 알고리즘이라는 기법도 있습니다.

데이터를 원형 큐에 저장후, 포인터가 가르키는 위치만 변경하여 페이지의 참조비트를 검사 및 조작합니다.
큐 내부에서 자료를 계속 옮길떄 발생하는 자원소모를 줄일 수있습니다.

2. 가상기억장치는 메모리 용량보다 더 큰 프로세스를 실행하게 해주는 기법입니다.

이는 프로세스의 일부만 메모리에 적재함으로써 가능한 방식입니다.

보조기억장치에 가상 메모리 주소를두고, cpu는 이를 참조하게 합니다.
실제로 사용중인 데이터만 메모리에 올려놓고, 사상표를 이용한 변환으로
가상 메모리주소를 실 주소로 변환하여 메모리의 정보를 cpu가 알수 있게합니다.

---
